/*! 
 *  \file obssim_unpack.c
 *
 */
#include <sys/types.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

#include <sys/socket.h>
#include <arpa/inet.h>

#include <assert.h>

static const char usage[] = 
  "Usage: obssim_unpack <localip> <port> <basedir> <pixelcnt>\n" \
  " where: <port> is the UDP port number to bind to\n" \
  "        <basedir> is the base directory for stored image files\n" \
  "        <pixelcnt> number of 16-bit values (pixels/hk) in a frame\n\n" \
  "\n" \
  " note: <pixelcnt> is used for Littlefield/Zynq software that\n" \
  "       omits a frame header and only contains pixel/housekeeping\n" \
  "       values.\n";

/*! \brief Maximum number of 16-bit values in a packet */
#define MAX_DATASIZE 1500

/*! \brief Packet Header
 *
 *  \details
 *  Packet header generated by the observatory simulator. Starts
 *  every UDP packet, and is immediately followed by 16-bit pixel/housekeeping
 *  data.
 */
struct packet_hdr {
  uint32_t size;		/* total # 16-bit values in frame */
  uint32_t frameno;		/* frame number, wraps at 0xffffffff */
  uint32_t index;		/* starting index of 1st value in packet */
};

/*! \brief Command line pixel count per image and header flag
 *						
 *  \details
 *  When greater than or equal to zero, specifies that:
 *  - UDP packets contain only pixel and housekeeping data; no header
 *  - The number of pixels in a frame
 *
 *  When less than zero, the pixel count, frame number, etc come
 *  from headers within the UDP packets sent from the Zynq
 */
int pixelcnt = -1;

/*! \brief Current frame number, ignore if pixelcnt < 0 */
size_t frameno = 0;

/*! \brief Current pixel within frame, ignore if pixelcnt < 0 */
size_t pixelindex = 0;

/*! \brief Full size packet definition
 *
 *  \details
 *  Full packet, including header and maximum number of data values.
 */
struct packet {
  struct packet_hdr hdr;
  uint16_t data[MAX_DATASIZE]; /* array of data values */
};

/*! \brief Byte swap the packet header fields into a packet structure
 *
 *  \details
 *  Unpacks and byte swaps packet header into a packet header structure
 *  and returns the number of data bytes consumed from the buffer.
 *
 *  \param buf Raw data buffer
 *  \param len Number of bytes in the raw data buffer
 *  \param pkt Packet pointer to fill
 *
 *  \returns Number of data bytes read from the buffer
 */
size_t parsehdr(const uint8_t *buf, size_t len, struct packet *pkt)
{
  size_t cnt = 0;

  pkt->hdr.size =
    (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];
  buf += sizeof(uint32_t);
  cnt += sizeof(uint32_t);

  pkt->hdr.frameno =
    (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];
  buf += sizeof(uint32_t);
  cnt += sizeof(uint32_t);

  pkt->hdr.index =
    (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];
  buf += sizeof(uint32_t);
  cnt += sizeof(uint32_t);

  return cnt;
}

/*! \brief Byte swap the packet fields into a packet structure
 *
 *  \details
 *  Unpacks and byte swaps packet header and data into a packet
 *  structure and returns the number of data bytes within the packet.
 *
 *  \param buf Raw data buffer
 *  \param len Number of bytes in the raw data buffer
 *  \param pkt Packet pointer to fill
 *
 *  \returns Number of data values in the packet
 */
size_t parsepkt(const uint8_t *buf, size_t len, struct packet *pkt)
{
  size_t pktdatacnt = 0;
  uint16_t *data;
  size_t cnt;

  assert((len % sizeof(uint16_t)) == 0);

  if (pixelcnt < 0) {
    /* packets contain header, parse it */
    cnt = parsehdr(buf, len, pkt);
    buf += cnt;
    len -= cnt;
  }
  else {
    /* packets don't have header, count pixels */
    pkt->hdr.size = pixelcnt;
    pkt->hdr.frameno = frameno;
    pkt->hdr.index = pixelindex;
  }

  /* unpack the pixel/housekeeping data */
  data = pkt->data;

  while (len) {
    *data++ = (buf[1] << 8) | buf[0];

    buf += sizeof(uint16_t);
    len -= sizeof(uint16_t);
    pktdatacnt++;
  }

  /* handle pixel counting if UDP packet's didn't have headers */
  if (pixelcnt >= 0) {
    /* no header, so count frames assuming we're in sync */
    pixelindex += pktdatacnt;	/* number of pixels in the packet */

    if (pixelindex >= pixelcnt) {
      /* completed a frame */
      frameno++;		/* bump the frame number */
      pixelindex = 0;		/* reset the pixel index within the frame */
    }
  }

  return pktdatacnt;
}

/*! \brief Open file based on packet number
 *
 *  \details
 *  Opens an image file based on the file's packet number
 *
 *  \param base Base pathname
 *  \param pkt Packet containing the frame number
 *
 *  \returns file descriptor, or negative value on error
 */
int openfile(const char *base, struct packet *pkt)
{
  char filename[80];
  int fd;

  snprintf(filename, sizeof(filename),
	   "%s%s-%d.bin", base, "obssim", pkt->hdr.frameno);

  fd = open(filename, O_CREAT | O_WRONLY, 0666);

  return fd;
}
 
/*! \brief Store data packet to output file
 *
 *  \details
 *  Stores a data packet to an output file, creating
 *  the output file if necessary.
 *
 *  \param base Base for generated pathnames
 *  \param pkt Packet buffer
 *  \param datacnt Number of 16-bit values to write
 *  \param lastframe Pointer to the previously written frame number
 *  \param lastfd Pointer to previously written file descriptor, or -1 if none
 *
 */
void storepkt(const char *base, struct packet *pkt, size_t datacnt,
	      uint32_t *lastframe, int *lastfd, off_t *lastpos)
{
  int fd;

  
  if (*lastfd < 0 || *lastframe != pkt->hdr.frameno) {

    if (*lastfd >= 0)
      close(*lastfd);

    /* no file or frame number changed, open the file */
    fd = openfile(base, pkt); 
  }
  else {
    fd = *lastfd;	/* use previous descriptor */
  }

  /* seek to indexed location within the file */
  if (*lastpos != (pkt->hdr.index * sizeof(uint16_t))) {
    /*
    if (lseek(fd, pkt->hdr.index * sizeof(uint16_t), SEEK_SET) < 0) {
      perror("lseek");
      return;
    }
    */
  }
  
  /* write the data */
  if (write(fd, pkt->data, datacnt * sizeof(uint16_t)) < 0) {
    perror("write");
    return;
  }

  *lastfd = fd;
  *lastframe = pkt->hdr.frameno;
  *lastpos = (pkt->hdr.index + datacnt) * sizeof(uint16_t);
}

/*! \brief Open UDP port for reading
 *
 *  \details
 *  Open a socket onto the UDP port for listening.
 *
 *  \param port Port number
 *
 *  \returns socket file descriptor, or a negative value
 *  on error.
 */
int udpopen(const char *host, int port)
{
  int sock;
  struct sockaddr_in inaddr;
  
  sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
  if (sock < 0)
    return sock;

  inaddr.sin_family = AF_INET;
  inaddr.sin_port = htons(port);
  inet_aton(host, &inaddr.sin_addr);

  if (bind(sock, (struct sockaddr *) &inaddr, sizeof(inaddr)) < 0) {
    close(sock);
    return -1;
  }

  return sock;
}

/*! \brief Wait for and read image packets, forming image files
 *
 *  \details
 *  Receives a series of UDP packets containing image data and
 *  writes those packets to data files.
 *
 *  \param base Base path for generated filenames
 *  \param sock UDP socket to read from
 *
 */
void readimages(const char *base, int sock)
{
  static uint8_t databuf[sizeof(struct packet)];
  static uint8_t prvbuf[sizeof(struct packet)];
  static struct packet pkt;
  int prvset = 0;
  size_t pktdatacnt;
  int lastfd = -1;		/* last open file descriptor */
  off_t lastpos = 0;		/* last file position */
  uint32_t lastframeno = 0;
  int nr;
  int first = 1;
  int time;
  int frame;

  /* loop until error on the read */
  for (;;) {

    if (first) {
      fprintf(stderr, "- Waiting for frame...");
      fflush(stderr);
    }

    /* read a UPD packet */
    nr = recv(sock, databuf, sizeof(databuf), 0);

    if (nr < 0)
      break;

    if (nr > 0) {
      if (sscanf((const char *)databuf,
		 "%d : Starting Frame - %d\n",
		 &time, &frame) == 2) {
	printf("%d : Starting Frame - %d\n", time, frame);
	first = 0;
	continue;
      }
    }

    if (prvset)
      if (memcmp(prvbuf, databuf, nr) == 0)
	printf("DUPLICATE PACKET\n");

    memcpy(prvbuf, databuf, nr);
    prvset = 1;

    /* parse the packet */
    pktdatacnt = parsepkt(databuf, nr, &pkt);

    /* store to file */
    storepkt(base, &pkt, pktdatacnt, &lastframeno, &lastfd, &lastpos);
  }

  /* close out cached open file descriptor */
  if (lastfd >= 0)
    close(lastfd);

}

/*! \brief Main to read and assemble images from the observatory sim
 *
 *  \details
 *  Listens for UDP packets on the observatory simulator port,
 *  assembles the pixel values in corresponding data files.
 *
 *  \param argc Number of arguments
 *  \param argv Argument list, where argv[0] is the program name,
 *  argv[1] is the port number to listen to, argv[2] is the base
 *  output pattern for generated files.
 *
 *  \returns 0 on success, non-zero on error
 */
int main(int argc, char **argv)
{
  int sock;

  if (argc < 5) {
    fprintf(stderr, "%s\n", usage);
    return -1;
  }

  pixelcnt = atoi(argv[4]);
  frameno = 0;
  pixelindex = 0;

  sock = udpopen(argv[2],atoi(argv[3]));
  if (sock < 0) {
    perror("udpopen");
    return -1;
  }

  readimages(argv[1],sock);

  close (sock);

  return 0;
}
